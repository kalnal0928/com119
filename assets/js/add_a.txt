주 20 정답: 초기 상태
CPU 레지스터: x4=13, x5=27, x6=40
메모리: 주소 20과 24에 각각 값이 저장되어 있음
명령어 실행 과정
1번 명령어: lw x4, 20(x0)
동작: 메모리 주소 20번지에서 데이터를 읽어와 x4 레지스터에 저장
CPU-메모리 상호작용:
CPU가 메모리 주소 20에 읽기 요청
메모리가 주소 20에 저장된 값(13)을 CPU로 전송
CPU가 이 값을 x4 레지스터에 저장
결과: x4 = 13 (메모리[20]에서 로드)
2번 명령어: lw x5, 24(x0)
동작: 메모리 주소 24번지에서 데이터를 읽어와 x5 레지스터에 저장
CPU-메모리 상호작용:
CPU가 메모리 주소 24에 읽기 요청
메모리가 주소 24에 저장된 값(27)을 CPU로 전송
CPU가 이 값을 x5 레지스터에 저장
결과: x5 = 27 (메모리[24]에서 로드)
3번 명령어: add x6, x4, x5 (주요 분석 대상)
CPU 내부 동작:
명령어 해독 단계:
명령어를 R-type ADD로 인식
rs1 = x4, rs2 = x5, rd = x6으로 파악
레지스터 파일 읽기:
x4 레지스터에서 값 13 읽기 (1번 명령어로 로드된 값)
x5 레지스터에서 값 27 읽기 (2번 명령어로 로드된 값)
ALU 연산 수행:
ALU에서 덧셈 연산 실행: 13 + 27 = 40
연산 결과 40 생성
결과 저장:
연산 결과 40을 목적지 레지스터 x6에 쓰기
레지스터 파일의 x6 값이 40으로 업데이트
메모리와의 상호작용:
메모리 접근 없음: 이 명령어는 순수한 레지스터 간 연산
모든 데이터는 이미 CPU 내부 레지스터에 존재
메모리 상태는 변경되지 않음
데이터 경로:
레지스터 파일(x4=13, x5=27) → ALU → 레지스터 파일(x6=40)
최종 상태
CPU 레지스터: x4=13, x5=27, x6=40
메모리: 변화 없음 (주소 20=13, 주소 24=27 유지)
핵심 특징
3번 명령어는 CPU 내부에서만 실행되어 매우 빠름
1, 2번 명령어가 메모리에서 데이터를 준비해둔 덕분에 가능
Load-Use 패턴의 전형적인 예시: 메모리에서 데이터를 로드한 후 연산에 활용


주 25 정답
먼저 레지스터 번호를 확인합니다:
t0 (목적지 레지스터 rd) = x5 = 5 (이진수: 00101)
s1 (소스 레지스터 rs1) = x9 = 9 (이진수: 01001)
s2 (소스 레지스터 rs2) = x18 = 18 (이진수: 10010)
R-type 명령어 형식 (32비트):
funct7 (7비트) | rs2 (5비트) | rs1 (5비트) | funct3 (3비트) | rd (5비트) | opcode (7비트)
각 필드를 채우면:
funct7  : 0000000 (7비트)
rs2     : 10010   (5비트) - s2 = x18
rs1     : 01001   (5비트) - s1 = x9  
funct3  : 000     (3비트)
rd      : 00101   (5비트) - t0 = x5
opcode  : 0110011 (7비트)
32비트 이진수로 연결:
0000000 10010 01001 000 00101 0110011
이를 4비트씩 그룹화하여 16진수로 변환:
0000 0001 0010 0100 1000 0010 1011 0011
  0    1    2    4    8    2    B    3
따라서 기계어 코드는: 0x012482B3
