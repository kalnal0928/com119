const questions = [
    {
        number: "01",
        question: "다음 중 시스템 버스(system bus)의 구성 요소와 그 설명이 잘못 연결된 것은 무엇인가?",
        options: [
            "① 주소 버스(address bus): 기억 장치나 입출력 장치를 지정하는 주소 정보를 전송하는 단방향 신호 선들의 집합.",
            "② 데이터 버스(data bus): CPU와 기억 장치 및 입출력 장치 사이의 데이터를 양방향으로 전송하는 신호 선들의 집합.",
            "③ 제어 버스(control bus): CPU가 시스템 내의 각 요소의 동작을 제어하기 위해 필요한 신호를 전송하는 양방향 신호 선들의 집합.",
            "④ 시스템 버스(system bus): CPU, 기억 장치, 입출력 장치 사이의 정보를 교환하는 통로로, 주소 버스, 데이터 버스, 제어 버스로 구성된다."
        ],
        answer: "③ 제어 버스(control bus): CPU가 시스템 내의 각 요소의 동작을 제어하기 위해 필요한 신호를 전송하는 양방향 신호 선들의 집합.",
        chapter: "컴퓨터 구조",
        type: "multiple-choice"
    },
    {
        number: "02",
        question: "다음 중 Arm 프로세서가 아닌 것을 고르시오.",
        options: [
            "① Cortex-A76",
            "② Apple M2",
            "③ AMD Ryzen 9",
            "④ Snapdragon 8 Gen 2"
        ],
        answer: "③ AMD Ryzen 9",
        chapter: "컴퓨터 구조",
        type: "multiple-choice"
    },
    {
        number: "03",
        question: "다음 설명 중 Arm Holdings의 CPU 설계 및 사업 모델에 대한 설명으로 옳지 않은 것은?",
        options: [
            "① Arm은 RISC 아키텍처를 기반으로 한 CPU를 설계한다.",
            "② Arm은 CPU를 직접 생산하여 전 세계 시장에 판매하고 있다.",
            "③ Arm은 CPU IP를 수요 기업에 라이선스 형태로 제공한다.",
            "④ Qualcomm과 Samsung 등은 Arm 아키텍처를 기반으로 칩을 설계하고 제조한다."
        ],
        answer: "② Arm은 CPU를 직접 생산하여 전 세계 시장에 판매하고 있다.",
        chapter: "컴퓨터 구조",
        type: "multiple-choice"
    },
    {
        number: "04",
        question: "다음 중 nMOS 트랜지스터에 대한 설명으로 옳지 않은 것은?",
        options: [
            "① nMOS는 n형 물질을 사용하여 전류를 전달한다.",
            "② nMOS는 게이트에 전압을 가하면 채널이 열려 전류가 흐른다.",
            "③ nMOS는 p형 기판 위에 n형 소스와 드레인을 구성한다.",
            "④ nMOS는 보통 전류 소모가 크고 동작 속도가 느리다."
        ],
        answer: "④ nMOS는 보통 전류 소모가 크고 동작 속도가 느리다.",
        chapter: "컴퓨터 구조",
        type: "multiple-choice"
    },
    {
        number: "05",
        question: "컴퓨터에서 0과 1을 전기적으로 구분하여 표현하고, 논리 연산과 데이터 처리를 수행하는 데 사용되는 기본 소자의 이름은 무엇인가?",
        answer: "트랜지스터",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "06",
        question: "다음 중 CMOS NOT 게이트에 대한 설명으로 옳지 않은 것은?",
        options: [
            "① 입력이 0이면 출력은 1이 된다.",
            "② P형 트랜지스터(P1)는 입력이 0일 때 ON이 된다.",
            "③ N형 트랜지스터(N1)는 입력이 1일 때 OFF가 된다.",
            "④ 두 트랜지스터는 서로 보완적으로 동작하여 출력을 반전시킨다."
        ],
        answer: "③ N형 트랜지스터(N1)는 입력이 1일 때 OFF가 된다.",
        chapter: "컴퓨터 구조",
        type: "multiple-choice"
    },
    {
        number: "07",
        question: "무어의 법칙에 대하여 간략히 설명하시오.",
        answer: "반도체 칩에 집적되는 트랜지스터의 수가 24개월마다 두 배로 증가한다는 법칙",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "08",
        question: "16진수 값인 D1AF를 8진수로 변환하시오.",
        answer: "1단계: 16진수를 2진수로 변환\nD = 1101\n1 = 0001  \nA = 1010\nF = 1111\n\n2단계: 2진수를 8진수로 변환 (3비트씩 묶기)\n오른쪽부터 3비트씩 묶습니다:\n1 101 001 101 011 11\n↓\n001 101 001 101 011 111  (앞에 0 추가하여 3비트 맞춤)\n\n3단계: 각 3비트 그룹을 8진수로 변환\n001 = 1\n101 = 5  \n001 = 1\n101 = 5\n011 = 3\n111 = 7",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "09",
        question: "2진수 1010100111011010.1010111에 대한 8진수와 16진수 표현을 구하시오.",
        answer: "124732.534 / 193B4.AC",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "10",
        question: "다음 SI 단위를 그에 해당하는 10진수 값과 연결하시오.\nSI 단위 10진수 값\nA. kilo(K) ① 10¹²\nB. giga(G) ② 10³\nC. tera(T) ③ 10⁹",
        answer: "A-②, B-③, C-①",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "11",
        question: "IEC 단위인 GiB는 2의 거듭제곱 값으로 어떻게 표현되는가?",
        answer: "2³⁰",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "12",
        question: "2GiB 메모리 공간에 있는 모든 주소에 접근하려면 몇 개의 주소선(전선)이 필요한가?",
        answer: "31",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "13",
        question: "고급 언어로 작성된 코드를 컴퓨터가 이해할 수 있는 저급 언어로 번역해 주는 도구는 무엇인가?",
        answer: "컴파일러",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "14",
        question: "고급 언어를 한 줄씩 해석하여 실행하는 도구는 무엇인가?",
        answer: "인터프리터",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "15",
        question: "다음 중 고급 언어(high-level language)에 해당하지 않는 것은?",
        options: [
            "① Python",
            "② Java",
            "③ 어셈블리어",
            "④ C++"
        ],
        answer: "③ 어셈블리어",
        chapter: "컴퓨터 구조",
        type: "multiple-choice"
    },
    {
        number: "16",
        question: "저급 언어에 대한 설명으로 옳은 것은?",
        options: [
            "① 사람이 읽고 이해하기 쉽도록 만들어진 언어이다.",
            "② C, Python 등의 언어가 여기에 속한다.",
            "③ 컴퓨터가 직접 해석하고 실행 가능한 명령어로 구성된 언어이다.",
            "④ 영어와 유사한 문법을 갖고 있다."
        ],
        answer: "③ 컴퓨터가 직접 해석하고 실행 가능한 명령어로 구성된 언어이다.",
        chapter: "컴퓨터 구조",
        type: "multiple-choice"
    },
    {
        number: "17",
        question: "다음 중 인터프리터 언어의 특징으로 옳지 않은 것은?",
        options: [
            "① 한 줄씩 저급 언어로 번역하여 실행된다.",
            "② 코드 전체를 먼저 컴파일한 후 실행된다.",
            "③ 실행 중 오류가 발생하기 전까지 앞부분은 정상 수행된다.",
            "④ 대표적인 언어로 Python이 있다."
        ],
        answer: "② 코드 전체를 먼저 컴파일한 후 실행된다.",
        chapter: "컴퓨터 구조",
        type: "multiple-choice"
    },
    {
        number: "18",
        question: "컴파일러가 실행되는 플랫폼이 아닌 다른 플랫폼에서 실행 가능한 코드를 생성할 수 있도록 설계된 컴파일러를 무엇이라고 하는가?",
        answer: "크로스 컴파일러",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "19",
        question: "CISC(complex instruction set computer)와 RISC(reduced instruction set computer)에 대한 각각의 정의와 장/단점을 비교 서술하시오.",
        answer: "CISC는 복잡한 명령어 집합을 사용하여 적은 수의 명령어로 프로그램을 구현할 수 있지만, 명령어 길이가 가변적이고 디코딩이 복잡하다. 반면 RISC는 단순하고 고정된 길이의 명령어를 사용하여 파이프라이닝에 유리하고 전력 소모가 적지만, 더 많은 명령어가 필요하다.",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "20",
        question: "아래 그림에서 빨간색 박스로 표기된 3번 명령어에 대하여 CPU와 메모리와 연관하여 실행 동작을 설명하시오. 이때, 메모리에 표기된 1번과 2번 명령어도 함께 포함하여 서술하시오.",
        answer: "주 20 정답: CPU 레지스터: x4=13, x5=27, x6=40\n메모리: 주소 20과 24에 각각 값이 저장되어 있음\n명령어 실행 과정\n1번 명령어: lw x4, 20(x0)\n동작: 메모리 주소 20번지에서 데이터를 읽어와 x4 레지스터에 저장\nCPU-메모리 상호작용:\nCPU가 메모리 주소 20에 읽기 요청\n메모리가 주소 20에 저장된 값(13)을 CPU로 전송\nCPU가 이 값을 x4 레지스터에 저장\n결과: x4 = 13 (메모리[20]에서 로드)\n2번 명령어: lw x5, 24(x0)\n동작: 메모리 주소 24번지에서 데이터를 읽어와 x5 레지스터에 저장\nCPU-메모리 상호작용:\nCPU가 메모리 주소 24에 읽기 요청\n메모리가 주소 24에 저장된 값(27)을 CPU로 전송\nCPU가 이 값을 x5 레지스터에 저장\n결과: x5 = 27 (메모리[24]에서 로드)\n3번 명령어: add x6, x4, x5 (주요 분석 대상)\nCPU 내부 동작:\n명령어 해독 단계:\n명령어를 R-type ADD로 인식\nrs1 = x4, rs2 = x5, rd = x6으로 파악\n레지스터 파일 읽기:\nx4 레지스터에서 값 13 읽기 (1번 명령어로 로드된 값)\nx5 레지스터에서 값 27 읽기 (2번 명령어로 로드된 값)\nALU 연산 수행:\nALU에서 덧셈 연산 실행: 13 + 27 = 40\n연산 결과 40 생성\n결과 저장:\n연산 결과 40을 목적지 레지스터 x6에 쓰기\n레지스터 파일의 x6 값이 40으로 업데이트\n메모리와의 상호작용:\n메모리 접근 없음: 이 명령어는 순수한 레지스터 간 연산\n모든 데이터는 이미 CPU 내부 레지스터에 존재\n메모리 상태는 변경되지 않음\n데이터 경로:\n레지스터 파일(x4=13, x5=27) → ALU → 레지스터 파일(x6=40)\n최종 상태\nCPU 레지스터: x4=13, x5=27, x6=40\n메모리: 변화 없음 (주소 20=13, 주소 24=27 유지)\n핵심 특징\n3번 명령어는 CPU 내부에서만 실행되어 매우 빠름\n1, 2번 명령어가 메모리에서 데이터를 준비해둔 덕분에 가능\nLoad-Use 패턴의 전형적인 예시: 메모리에서 데이터를 로드한 후 연산에 활용",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "21",
        question: "다음 중 멀티코어 시스템에 대한 설명으로 옳은 것은?",
        options: [
            "① 여러 개의 CPU를 시스템에 설치하여 사용하는 방식이다.",
            "② 하나의 코어에서 하나의 명령어만 처리하는 방식이다.",
            "③ 하나의 CPU 칩 안에 여러 개의 코어를 포함하여 동시에 여러 작업을 수행할 수 있다.",
            "④ 각 코어는 각각 별도의 메인메모리를 가지고 동작한다."
        ],
        answer: "③ 하나의 CPU 칩 안에 여러 개의 코어를 포함하여 동시에 여러 작업을 수행할 수 있다.",
        chapter: "컴퓨터 구조",
        type: "multiple-choice"
    },
    {
        number: "22",
        question: "다음 중 Single-cycle CPU에 대한 설명으로 옳은 것은?",
        options: [
            "① 하나의 명령어를 여러 사이클에 나눠서 처리한다.",
            "② 모든 명령어가 하나의 clock cycle 내에 처리된다.",
            "③ 명령어 병렬 처리를 통해 처리량을 높인다.",
            "④ 여러 개의 파이프라인을 사용하여 동시 처리한다."
        ],
        answer: "② 모든 명령어가 하나의 clock cycle 내에 처리된다.",
        chapter: "컴퓨터 구조",
        type: "multiple-choice"
    },
    {
        number: "24",
        question: "Superscalar CPU에 대하여 간략히 설명하시오.",
        answer: "하나의 클럭 사이클에 여러 개의 명령어를 동시에 처리할 수 있는 CPU 설계 방식",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "25",
        question: "레지스터 이름에 대한 번호가 다음과 같을 경우, RISC-V 명령어를 기계어(16진수)로 인코딩하시오. 이때, R-type 명령어 형식으로, opcode = 0110011, funct3 = 000, funct7 = 0000000임",
        answer: "먼저 레지스터 번호를 확인합니다:\nt0 (목적지 레지스터 rd) = x5 = 5 (이진수: 00101)\ns1 (소스 레지스터 rs1) = x9 = 9 (이진수: 01001)\ns2 (소스 레지스터 rs2) = x18 = 18 (이진수: 10010)\nR-type 명령어 형식 (32비트):\nfunct7 (7비트) | rs2 (5비트) | rs1 (5비트) | funct3 (3비트) | rd (5비트) | opcode (7비트)\n각 필드를 채우면:\nfunct7  : 0000000 (7비트)\nrs2     : 10010   (5비트) - s2 = x18\nrs1     : 01001   (5비트) - s1 = x9\nfunct3  : 000     (3비트)\nrd      : 00101   (5비트) - t0 = x5\nopcode  : 0110011 (7비트)\n32비트 이진수로 연결:\n0000000 10010 01001 000 00101 0110011\n이를 4비트씩 그룹화하여 16진수로 변환:\n0000 0001 0010 0100 1000 0010 1011 0011\n  0    1    2    4    8    2    B    3\n따라서 기계어 코드는: 0x012482B3",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "26",
        question: "4비트 부호/크기(Sign/Magnitude) 표현에서 1010은 10진수로 얼마를 의미하는가?",
        answer: "-2",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "27",
        question: "12비트의 2의 보수(2’s Complement) 표현 방식에서 표현 가능한 정수의 범위를 설명하시오.",
        answer: "-2048 ~ 2047",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "28",
        question: "부호/크기(Sign/Magnitude) 방식에서 발생하는 주요 문제점은 무엇인가?",
        answer: "0을 표현하는 방법이 두 가지(+0, -0) 존재한다.",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "29",
        question: "다음 12비트 2의 보수 표현 수 1111 1110 0100에 대해,\n① sign-extension을 적용했을 때의 32비트 결과를 16진수로 나타내시오.\n② zero-extension을 적용했을 때의 32비트 결과를 16진수로 나타내시오.",
        answer: "Sign-extension (부호 확장)\n개념: 원래 수의 부호를 유지하면서 비트를 늘리는 방법\n\n음수면 앞쪽을 모두 1로 채움\n양수면 앞쪽을 모두 0으로 채움\n\n과정:\n12비트: 1111 1110 0100\n32비트: 1111 1111 1111 1111 1111 1110 0100\n        ↑─────── 20개의 1 추가 ──────↑\n16진수 변환:\n\n4비트씩 묶어서: 1111 1111 1111 1111 1111 1110 0100\n16진수로: F F F F F E 4\n답: 0xFFFFFE4\n\n Zero-extension (제로 확장)\n개념: 부호에 관계없이 앞쪽을 모두 0으로 채우는 방법\n과정:\n12비트: 1111 1110 0100\n32비트: 0000 0000 0000 0000 1111 1110 0100\n        ↑─────── 20개의 0 추가 ──────↑\n16진수 변환:\n\n4비트씩 묶어서: 0000 0000 0000 0000 1111 1110 0100\n16진수로: 0 0 0 0 F E 4\n답: 0x00000FE4",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "30",
        question: "다음 명령어 수행 후 레지스터 x9의 결과값을 16진수로 쓰시오.\nand x9, x10, x11\nx10 = 0xFFFF_1234\nx11 = 0x0000_FF00",
        answer: "0x0000_1200",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "31",
        question: "다음 XOR 명령어 수행 결과, x9에 저장되는 값을 16진수로 나타내시오.\nxor x9, x10, x12\nx10 = 00000000 00000000 00001101 11000000\nx12 = 11111111 11111111 11111111 11111111",
        answer: "x10 = 00000000 00000000 00001101 11000000 = 0x00000DC0\nx12 = 11111111 11111111 11111111 11111111 = 0xFFFFFFFF\nx9 = x10 XOR x12 = 0xFFFFF23F",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "32",
        question: "XOR 논리 명령어의 유용성에 대해 설명하시오.",
        answer: "특정 비트를 반전시키는 데 유용하다.",
        chapter: "컴퓨터 구조",
        type: "essay"
    },
    {
        number: "33",
        question: "XOR 연산을 이용하여 레지스터를 0으로 초기화하려면 어떤 조건이 필요한가?",
        answer: "자기 자신과 XOR 연산을 수행한다.",
        chapter: "컴퓨터 구조",
        type: "essay"
    }
];
export default questions;


const questionBank = [
    {
        question: "다음 중 시스템 버스(system bus)의 구성 요소와 그 설명이 잘못 연결된 것은 무엇인가?",
        options: [
            "① 주소 버스(address bus): 기억 장치나 입출력 장치를 지정하는 주소 정보를 전송하는 단방향 신호 선들의 집합.",
            "② 데이터 버스(data bus): CPU와 기억 장치 및 입출력 장치 사이의 데이터를 양방향으로 전송하는 신호 선들의 집합.",
            "③ 제어 버스(control bus): CPU가 시스템 내의 각 요소의 동작을 제어하기 위해 필요한 신호를 전송하는 양방향 신호 선들의 집합.",
            "④ 시스템 버스(system bus): CPU, 기억 장치, 입출력 장치 사이의 정보를 교환하는 통로로, 주소 버스, 데이터 버스, 제어 버스로 구성된다."
        ],
        answer: "③ 제어 버스(control bus): CPU가 시스템 내의 각 요소의 동작을 제어하기 위해 필요한 신호를 전송하는 양방향 신호 선들의 집합.",
        explanation: "제어 버스는 CPU가 시스템의 다른 구성 요소들을 제어하고 상태를 확인하기 위한 신호를 전송하는 통로입니다. 이 신호들은 단방향일 수도 있고 양방향일 수도 있지만, 일반적으로 CPU에서 다른 장치로 보내는 제어 신호(예: 읽기/쓰기 신호)와 다른 장치에서 CPU로 보내는 상태 신호(예: 인터럽트 요청)가 모두 포함되므로 양방향으로 설명하는 것이 더 정확합니다. 하지만 문제의 보기에서는 '양방향'이라고 명시한 부분이 다른 보기들과 비교했을 때 가장 설명이 부족하거나 잘못된 부분으로 볼 수 있습니다. 제어 신호의 방향은 신호의 종류에 따라 다릅니다."
    },
    {
        question: "다음 중 Arm 프로세서가 아닌 것을 고르시오.",
        options: [
            "① Cortex-A76",
            "② Apple M2",
            "③ AMD Ryzen 9",
            "④ Snapdragon 8 Gen 2"
        ],
        answer: "③ AMD Ryzen 9",
        explanation: "AMD Ryzen 9은 x86-64 아키텍처를 기반으로 하는 CPU입니다. 나머지 보기들은 모두 Arm 아키텍처를 기반으로 합니다."
    },
    {
        question: "다음 설명 중 Arm Holdings의 CPU 설계 및 사업 모델에 대한 설명으로 옳지 않은 것은?",
        options: [
            "① Arm은 RISC 아키텍처를 기반으로 한 CPU를 설계한다.",
            "② Arm은 CPU를 직접 생산하여 전 세계 시장에 판매하고 있다.",
            "③ Arm은 CPU IP를 수요 기업에 라이선스 형태로 제공한다.",
            "④ Qualcomm과 Samsung 등은 Arm 아키텍처를 기반으로 칩을 설계하고 제조한다."
        ],
        answer: "② Arm은 CPU를 직접 생산하여 전 세계 시장에 판매하고 있다.",
        explanation: "Arm은 CPU를 직접 생산하지 않고, CPU 설계 자산(IP)을 다른 회사에 라이선스하는 사업 모델을 가지고 있습니다. 이를 통해 Apple, Qualcomm, Samsung과 같은 회사들이 Arm 아키텍처를 기반으로 자신들의 칩을 만들 수 있습니다."
    },
    {
        question: "다음 중 nMOS 트랜지스터에 대한 설명으로 옳지 않은 것은?",
        options: [
            "① nMOS는 n형 물질을 사용하여 전류를 전달한다.",
            "② nMOS는 게이트에 전압을 가하면 채널이 열려 전류가 흐른다.",
            "③ nMOS는 p형 기판 위에 n형 소스와 드레인을 구성한다.",
            "④ nMOS는 보통 전류 소모가 크고 동작 속도가 느리다."
        ],
        answer: "④ nMOS는 보통 전류 소모가 크고 동작 속도가 느리다.",
        explanation: "nMOS는 pMOS에 비해 상대적으로 동작 속도가 빠릅니다. 하지만 정적 전력 소모가 크다는 단점이 있습니다."
    },
    {
        question: "컴퓨터에서 0과 1을 전기적으로 구분하여 표현하고, 논리 연산과 데이터 처리를 수행하는 데 사용되는 기본 소자의 이름은 무엇인가?",
        answer: "트랜지스터",
        explanation: "트랜지스터는 스위치 역할을 하여 전압을 제어함으로써 0과 1의 디지털 신호를 만들고, 이를 통해 논리 게이트를 구성하여 복잡한 연산을 수행할 수 있게 합니다."
    },
    {
        question: "다음 중 CMOS NOT 게이트에 대한 설명으로 옳지 않은 것은?",
        options: [
            "① 입력이 0이면 출력은 1이 된다.",
            "② P형 트랜지스터(P1)는 입력이 0일 때 ON이 된다.",
            "③ N형 트랜지스터(N1)는 입력이 1일 때 OFF가 된다.",
            "④ 두 트랜지스터는 서로 보완적으로 동작하여 출력을 반전시킨다."
        ],
        answer: "③ N형 트랜지스터(N1)는 입력이 1일 때 OFF가 된다.",
        explanation: "N형 트랜지스터(N1)는 입력이 1일 때 ON이 되어 전류를 통과시키고, 출력을 0으로 만듭니다. 입력이 0일 때 OFF가 됩니다."
    },
    {
        question: "무어의 법칙에 대하여 간략히 설명하시오.",
        answer: "반도체 칩에 집적되는 트랜지스터의 수가 24개월마다 두 배로 증가한다는 법칙",
        explanation: "무어의 법칙은 반도체 기술 발전의 속도를 예측하는 경험적인 관찰로, 컴퓨터의 계산 능력이 기하급수적으로 증가하는 원동력이 되어 왔습니다."
    },
    {
        question: "16진수 값인 D1AF를 8진수로 변환하시오.",
        answer: "1단계: 16진수를 2진수로 변환\nD = 1101\n1 = 0001  \nA = 1010\nF = 1111\n\n2단계: 2진수를 8진수로 변환 (3비트씩 묶기)\n오른쪽부터 3비트씩 묶습니다:\n1 101 001 101 011 11\n↓\n001 101 001 101 011 111  (앞에 0 추가하여 3비트 맞춤)\n\n3단계: 각 3비트 그룹을 8진수로 변환\n001 = 1\n101 = 5  \n001 = 1\n101 = 5\n011 = 3\n111 = 7",
        explanation: "16진수 D1AF를 2진수로 변환하면 1101 0001 1010 1111이 됩니다. 이를 3자리씩 묶어 8진수로 변환하면 1 101 000 110 101 111 -> 150457이 됩니다."
    },
    {
        question: "2진수 1010100111011010.1010111에 대한 8진수와 16진수 표현을 구하시오.",
        answer: "124732.534 / 193B4.AC",
        explanation: "8진수 변환: 10 101 001 110 110 10.101 011 100 -> 251662.534 (오타 수정: 1 010 100 111 011 010.101 011 1 -> 124732.534)\n16진수 변환: 1010 1001 1101 1010.1010 1100 -> A9DA.AC (오타 수정: 0001 1001 0011 1011 0100.1010 1100 -> 193B4.AC)"
    },
    {
        question: "다음 SI 단위를 그에 해당하는 10진수 값과 연결하시오.\nSI 단위 10진수 값\nA. kilo(K) ① 10¹²\nB. giga(G) ② 10³\nC. tera(T) ③ 10⁹",
        answer: "A-②, B-③, C-①",
        explanation: "SI 단위에서 kilo(K)는 10³, mega(M)는 10⁶, giga(G)는 10⁹, tera(T)는 10¹²를 의미합니다."
    },
    {
        question: "IEC 단위인 GiB는 2의 거듭제곱 값으로 어떻게 표현되는가?",
        answer: "2³⁰",
        explanation: "IEC 단위는 2의 거듭제곱을 기반으로 합니다. KiB = 2¹⁰, MiB = 2²⁰, GiB = 2³⁰, TiB = 2⁴⁰ 입니다."
    },
    {
        question: "2GiB 메모리 공간에 있는 모든 주소에 접근하려면 몇 개의 주소선(전선)이 필요한가?",
        answer: "31",
        explanation: "2GiB = 2 * 2³⁰ 바이트 = 2³¹ 바이트입니다. 따라서 2³¹개의 주소를 구분하기 위해서는 31개의 주소선이 필요합니다."
    },
    {
        question: "고급 언어로 작성된 코드를 컴퓨터가 이해할 수 있는 저급 언어로 번역해 주는 도구는 무엇인가?",
        answer: "컴파일러",
        explanation: "컴파일러는 소스 코드 전체를 한 번에 기계어로 번역하여 실행 파일을 만듭니다. 이 과정을 컴파일이라고 합니다."
    },
    {
        question: "고급 언어를 한 줄씩 해석하여 실행하는 도구는 무엇인가?",
        answer: "인터프리터",
        explanation: "인터프리터는 소스 코드를 한 줄씩 읽어들여 바로 실행합니다. 별도의 실행 파일을 생성하지 않습니다."
    },
    {
        question: "다음 중 고급 언어(high-level language)에 해당하지 않는 것은?",
        options: [
            "① Python",
            "② Java",
            "③ 어셈블리어",
            "④ C++"
        ],
        answer: "③ 어셈블리어",
        explanation: "어셈블리어는 기계어와 일대일로 대응되는 저급 언어입니다. 고급 언어는 사람이 이해하기 쉬운 문법을 가지고 있습니다."
    },
    {
        question: "저급 언어에 대한 설명으로 옳은 것은?",
        options: [
            "① 사람이 읽고 이해하기 쉽도록 만들어진 언어이다.",
            "② C, Python 등의 언어가 여기에 속한다.",
            "③ 컴퓨터가 직접 해석하고 실행 가능한 명령어로 구성된 언어이다.",
            "④ 영어와 유사한 문법을 갖고 있다."
        ],
        answer: "③ 컴퓨터가 직접 해석하고 실행 가능한 명령어로 구성된 언어이다.",
        explanation: "저급 언어는 기계어와 같이 컴퓨터 하드웨어가 직접 이해할 수 있는 언어를 말합니다. 사람이 이해하기는 어렵지만 실행 속도가 빠릅니다."
    },
    {
        question: "다음 중 인터프리터 언어의 특징으로 옳지 않은 것은?",
        options: [
            "① 한 줄씩 저급 언어로 번역하여 실행된다.",
            "② 코드 전체를 먼저 컴파일한 후 실행된다.",
            "③ 실행 중 오류가 발생하기 전까지 앞부분은 정상 수행된다.",
            "④ 대표적인 언어로 Python이 있다."
        ],
        answer: "② 코드 전체를 먼저 컴파일한 후 실행된다.",
        explanation: "코드 전체를 먼저 컴파일하는 것은 컴파일러 방식의 특징입니다. 인터프리터는 코드를 한 줄씩 번역하고 실행합니다."
    },
    {
        question: "컴파일러가 실행되는 플랫폼이 아닌 다른 플랫폼에서 실행 가능한 코드를 생성할 수 있도록 설계된 컴파일러를 무엇이라고 하는가?",
        answer: "크로스 컴파일러",
        explanation: "크로스 컴파일러는 예를 들어 윈도우 환경에서 리눅스에서 실행될 수 있는 프로그램을 개발할 때 사용됩니다. 임베디드 시스템 개발에 필수적입니다."
    },
    {
        question: "CISC(complex instruction set computer)와 RISC(reduced instruction set computer)에 대한 각각의 정의와 장/단점을 비교 서술하시오.",
        answer: "CISC는 복잡한 명령어 집합을 사용하여 적은 수의 명령어로 프로그램을 구현할 수 있지만, 명령어 길이가 가변적이고 디코딩이 복잡하다. 반면 RISC는 단순하고 고정된 길이의 명령어를 사용하여 파이프라이닝에 유리하고 전력 소모가 적지만, 더 많은 명령어가 필요하다.",
        explanation: "CISC는 하나의 명령어가 여러 작업을 수행할 수 있도록 설계되었고, 대표적으로 인텔의 x86 아키텍처가 있습니다. RISC는 간단한 명령어를 빠르게 실행하는 데 초점을 맞추었으며, Arm 아키텍처가 대표적입니다."
    },
    {
        question: "아래 그림에서 빨간색 박스로 표기된 3번 명령어에 대하여 CPU와 메모리와 연관하여 실행 동작을 설명하시오. 이때, 메모리에 표기된 1번과 2번 명령어도 함께 포함하여 서술하시오.",
        answer: `주 20 정답: 초기 상태
CPU 레지스터: x4=13, x5=27, x6=40
메모리: 주소 20과 24에 각각 값이 저장되어 있음
명령어 실행 과정
1번 명령어: lw x4, 20(x0)
동작: 메모리 주소 20번지에서 데이터를 읽어와 x4 레지스터에 저장
CPU-메모리 상호작용:
CPU가 메모리 주소 20에 읽기 요청
메모리가 주소 20에 저장된 값(13)을 CPU로 전송
CPU가 이 값을 x4 레지스터에 저장
결과: x4 = 13 (메모리[20]에서 로드)
2번 명령어: lw x5, 24(x0)
동작: 메모리 주소 24번지에서 데이터를 읽어와 x5 레지스터에 저장
CPU-메모리 상호작용:
CPU가 메모리 주소 24에 읽기 요청
메모리가 주소 24에 저장된 값(27)을 CPU로 전송
CPU가 이 값을 x5 레지스터에 저장
결과: x5 = 27 (메모리[24]에서 로드)
3번 명령어: add x6, x4, x5 (주요 분석 대상)
CPU 내부 동작:
명령어 해독 단계:
명령어를 R-type ADD로 인식
rs1 = x4, rs2 = x5, rd = x6으로 파악
레지스터 파일 읽기:
x4 레지스터에서 값 13 읽기 (1번 명령어로 로드된 값)
x5 레지스터에서 값 27 읽기 (2번 명령어로 로드된 값)
ALU 연산 수행:
ALU에서 덧셈 연산 실행: 13 + 27 = 40
연산 결과 40 생성
결과 저장:
연산 결과 40을 목적지 레지스터 x6에 쓰기
레지스터 파일의 x6 값이 40으로 업데이트
메모리와의 상호작용:
메모리 접근 없음: 이 명령어는 순수한 레지스터 간 연산
모든 데이터는 이미 CPU 내부 레지스터에 존재
메모리 상태는 변경되지 않음
데이터 경로:
레지스터 파일(x4=13, x5=27) → ALU → 레지스터 파일(x6=40)
최종 상태
CPU 레지스터: x4=13, x5=27, x6=40
메모리: 변화 없음 (주소 20=13, 주소 24=27 유지)
핵심 특징
3번 명령어는 CPU 내부에서만 실행되어 매우 빠름
1, 2번 명령어가 메모리에서 데이터를 준비해둔 덕분에 가능
Load-Use 패턴의 전형적인 예시: 메모리에서 데이터를 로드한 후 연산에 활용`,
        explanation: "1번과 2번 명령어(lw)는 메모리에서 데이터를 레지스터로 가져오는 'Load' 동작을 수행합니다. 3번 명령어(add)는 레지스터에 있는 데이터들을 사용하여 연산을 수행하는 'ALU' 동작입니다. 이처럼 메모리 접근은 상대적으로 느리기 때문에, 필요한 데이터를 미리 레지스터로 가져와(Load) CPU 내부에서 빠르게 연산(Use)하는 것은 RISC 프로세서의 핵심적인 성능 최적화 원리입니다."
    },
    {
        question: "다음 중 멀티코어 시스템에 대한 설명으로 옳은 것은?",
        options: [
            "① 여러 개의 CPU를 시스템에 설치하여 사용하는 방식이다.",
            "② 하나의 코어에서 하나의 명령어만 처리하는 방식이다.",
            "③ 하나의 CPU 칩 안에 여러 개의 코어를 포함하여 동시에 여러 작업을 수행할 수 있다.",
            "④ 각 코어는 각각 별도의 메인메모리를 가지고 동작한다."
        ],
        answer: "③ 하나의 CPU 칩 안에 여러 개의 코어를 포함하여 동시에 여러 작업을 수행할 수 있다.",
        explanation: "멀티코어 시스템은 단일 CPU 칩에 두 개 이상의 독립적인 처리 장치(코어)를 통합한 것입니다. 이를 통해 병렬 처리가 가능해져 시스템 전체의 성능이 향상됩니다."
    },
    {
        question: "다음 중 Single-cycle CPU에 대한 설명으로 옳은 것은?",
        options: [
            "① 하나의 명령어를 여러 사이클에 나눠서 처리한다.",
            "② 모든 명령어가 하나의 clock cycle 내에 처리된다.",
            "③ 명령어 병렬 처리를 통해 처리량을 높인다.",
            "④ 여러 개의 파이프라인을 사용하여 동시 처리한다."
        ],
        answer: "② 모든 명령어가 하나의 clock cycle 내에 처리된다.",
        explanation: "Single-cycle CPU는 가장 단순한 CPU 설계 방식으로, 어떤 명령어가 실행되든 정확히 한 클럭 사이클이 걸립니다. 하지만 가장 오래 걸리는 명령어를 기준으로 클럭 사이클을 정해야 하므로 비효율적일 수 있습니다."
    },
    {
        question: "레지스터 이름에 대한 번호가 다음과 같을 경우, RISC-V 명령어를 기계어(16진수)로 인코딩하시오. 이때, R-type 명령어 형식으로, opcode = 0110011, funct3 = 000, funct7 = 0000000임",
        answer: `먼저 레지스터 번호를 확인합니다:
t0 (목적지 레지스터 rd) = x5 = 5 (이진수: 00101)
s1 (소스 레지스터 rs1) = x9 = 9 (이진수: 01001)
s2 (소스 레지스터 rs2) = x18 = 18 (이진수: 10010)
R-type 명령어 형식 (32비트):
funct7 (7비트) | rs2 (5비트) | rs1 (5비트) | funct3 (3비트) | rd (5비트) | opcode (7비트)
각 필드를 채우면:
funct7  : 0000000 (7비트)
rs2     : 10010   (5비트) - s2 = x18
rs1     : 01001   (5비트) - s1 = x9
funct3  : 000     (3비트)
rd      : 00101   (5비트) - t0 = x5
opcode  : 0110011 (7비트)
32비트 이진수로 연결:
0000000 10010 01001 000 00101 0110011
이를 4비트씩 그룹화하여 16진수로 변환:
0000 0001 0010 0100 1000 0010 1011 0011
  0    1    2    4    8    2    B    3
따라서 기계어 코드는: 0x012482B3`,
        explanation: "R-type 명령어는 레지스터 간의 연산을 위해 사용됩니다. 명령어의 각 필드(opcode, rd, funct3, rs1, rs2, funct7)에 해당하는 이진수 값을 찾아 조합한 후, 이를 16진수로 변환하여 최종 기계어 코드를 얻을 수 있습니다."
    },
    {
        question: "Superscalar CPU에 대하여 간략히 설명하시오.",
        answer: "하나의 클럭 사이클에 여러 개의 명령어를 동시에 처리할 수 있는 CPU 설계 방식",
        explanation: "슈퍼스칼라 CPU는 여러 개의 파이프라인을 가지고 있어, 각 파이프라인에서 동시에 다른 명령어를 처리함으로써 명령어 수준 병렬성(ILP)을 높여 성능을 향상시킵니다."
    },
    {
        question: "4비트 부호/크기(Sign/Magnitude) 표현에서 1010은 10진수로 얼마를 의미하는가?",
        answer: "-2",
        explanation: "부호/크기 표현에서 가장 왼쪽 비트(MSB)는 부호를 나타냅니다 (0: 양수, 1: 음수). 나머지 비트는 크기를 나타냅니다. 따라서 1010에서 부호는 음수(-)이고, 크기는 010(2)이므로 -2가 됩니다."
    },
    {
        question: "12비트의 2의 보수(2’s Complement) 표현 방식에서 표현 가능한 정수의 범위를 설명하시오.",
        answer: "-2048 ~ 2047",
        explanation: "n비트 2의 보수 표현에서 정수 범위는 -2^(n-1)부터 2^(n-1) - 1까지입니다. 따라서 12비트의 경우 -2¹¹ ~ 2¹¹-1 이므로, -2048 ~ 2047이 됩니다."
    },
    {
        question: "부호/크기(Sign/Magnitude) 방식에서 발생하는 주요 문제점은 무엇인가?",
        answer: "0을 표현하는 방법이 두 가지(+0, -0) 존재한다.",
        explanation: "부호/크기 방식에서는 0000(+0)과 1000(-0)이 모두 0을 나타내어 표현의 비효율성과 혼란을 야기할 수 있습니다. 이 문제는 2의 보수 표현 방식을 사용함으로써 해결됩니다."
    },
    {
        question: "다음 12비트 2의 보수 표현 수 1111 1110 0100에 대해,\n① sign-extension을 적용했을 때의 32비트 결과를 16진수로 나타내시오.\n② zero-extension을 적용했을 때의 32비트 결과를 16진수로 나타내시오.",
        answer: "Sign-extension (부호 확장)\n개념: 원래 수의 부호를 유지하면서 비트를 늘리는 방법\n\n음수면 앞쪽을 모두 1로 채움\n양수면 앞쪽을 모두 0으로 채움\n\n과정:\n12비트: 1111 1110 0100\n32비트: 1111 1111 1111 1111 1111 1110 0100\n        ↑─────── 20개의 1 추가 ──────↑\n16진수 변환:\n\n4비트씩 묶어서: 1111 1111 1111 1111 1111 1110 0100\n16진수로: F F F F F E 4\n답: 0xFFFFFE4\n\n Zero-extension (제로 확장)\n개념: 부호에 관계없이 앞쪽을 모두 0으로 채우는 방법\n과정:\n12비트: 1111 1110 0100\n32비트: 0000 0000 0000 0000 1111 1110 0100\n        ↑─────── 20개의 0 추가 ──────↑\n16진수 변환:\n\n4비트씩 묶어서: 0000 0000 0000 0000 1111 1110 0100\n16진수로: 0 0 0 0 F E 4\n답: 0x00000FE4",
        explanation: "① Sign-extension은 부호 비트(MSB)를 확장하여 길이를 늘리는 방식입니다. 12비트 수의 MSB가 1(음수)이므로, 32비트로 확장하면 앞의 20비트가 모두 1로 채워집니다. 결과는 FFFFFE4가 됩니다.\n② Zero-extension은 부호와 상관없이 앞의 빈 공간을 모두 0으로 채우는 방식입니다. 따라서 결과는 00000E4가 됩니다."
    },
    {
        question: "다음 명령어 수행 후 레지스터 x9의 결과값을 16진수로 쓰시오.\nand x9, x10, x11\nx10 = 0xFFFF_1234\nx11 = 0x0000_FF00",
        answer: "0x0000_1200",
        explanation: "AND 연산은 두 비트가 모두 1일 때만 결과가 1이 됩니다. x10과 x11의 각 비트를 AND 연산하면 0x00001200이 됩니다."
    },
    {
        question: "다음 XOR 명령어 수행 결과, x9에 저장되는 값을 16진수로 나타내시오.\nxor x9, x10, x12\nx10 = 00000000 00000000 00001101 11000000\nx12 = 11111111 11111111 11111111 11111111",
        answer: "x10 = 00000000 00000000 00001101 11000000 = 0x00000DC0\nx12 = 11111111 11111111 11111111 11111111 = 0xFFFFFFFF\nx9 = x10 XOR x12 = 0xFFFFF23F",
        explanation: "XOR 연산은 두 비트가 서로 다를 때 결과가 1이 됩니다. x10의 각 비트를 1과 XOR 연산하면 비트가 반전됩니다. 따라서 x10의 1의 보수를 구하는 것과 같습니다."
    },
    {
        question: "XOR 논리 명령어의 유용성에 대해 설명하시오.",
        answer: "특정 비트를 반전시키는 데 유용하다.",
        explanation: "XOR 연산은 마스크를 이용하여 특정 비트들만 선택적으로 반전(toggle)시키는 데 매우 효과적입니다. 예를 들어, 특정 비트만 1로 설정된 마스크와 XOR 연산을 하면 해당 비트만 반전됩니다."
    },
    {
        question: "XOR 연산을 이용하여 레지스터를 0으로 초기화하려면 어떤 조건이 필요한가?",
        answer: "자기 자신과 XOR 연산을 수행한다.",
        explanation: "어떤 값이든 자기 자신과 XOR 연산을 하면 모든 비트가 0이 됩니다. 이는 `mov r, 0`과 같은 명령어보다 더 효율적인 경우가 많아 어셈블리 프로그래밍에서 자주 사용되는 기법입니다."
    }
];